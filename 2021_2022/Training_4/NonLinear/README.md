# NonLinear

## Задание

Дан код

```python
from Crypto.Util.number import getPrime
import random


def generator(seed, mod):
	for i in range(100):
		yield((seed := -~seed) * seed + -~-seed) % mod


mod = getPrime(16)
flag = open("flag", 'rb').read().strip()
enc = []

seed = getPrime(16)
while seed >= mod:
	seed = getPrime(16)

gamma = generator(seed, mod)
for byte in flag:
	enc.append((byte * next(gamma)) % mod)

print(mod)
print(enc)

# 64019
# [54084, 27604, 3282, 26722, 61736, 1001, 62309, 37331, 34255, 14307, 62569, 59696, 51933, 33047, 31188, 5703, 6977, 44713, 54910, 9982, 55344, 23729, 13244, 18992, 23519, 43736, 32090, 38916, 22016, 2851, 20090, 28801, 39710, 17447, 59221, 10138, 51530, 63651, 60912, 38358, 42431, 57996]
```

## Решение

Во-первых, заметим, что флаг разбивается на байты

![img1](./src/img1.png)

И каждый байт шифруется по формуле

![img2](./src/img2.png)

Соответственно, чтобы получить значение флага, нужно произвести обратное вычисление

![img3](./src/img3.png)

Проблема состоит в поиске значений `g`. Эти значения вычисляются в функции

```python
def generator(seed, mod):
	for i in range(100):
		yield((seed := -~seed) * seed + -~-seed) % mod
```

В этом коде есть 3 необычных операции

1) `-~seed`

2) `-~-seed`

3) `(seed := -~seed)`

Первые две легко понять, если попробовать эти операции на каком-нибудь реальном значении

```
>>> seed = 17
>>> -~seed
18
>>> -~-seed
-16
>>>
```

Значит первая операция на самом деле делает `seed + 1`, а вторая `-(seed - 1)`.

Третья операция это присваивание внутри выражения, т.е. как только выполнится `seed := -~seed`, значение `seed` во всём остальном выражении будет новым. Пример:

```
>>> seed = 5
>>> (seed := 3) + seed
6
>>> seed
3
```

Здесь сначала значение `seed` меняется на `3`, а потом это новое значение прибавляется к `seed`, которое тоже уже стало `3`, поэтому результат `6`. С другой стороны:

```
>>> seed = 5
>>> (seed + 1) + (seed := 3)
9
>>> seed
3
```

Здесь сначала выполнится `seed + 1` со старым значением `seed`, поэтому вернётся `6`, но потом значение `seed` меняется на `3` и вычисляется `6 + 3 = 9`. Заметьте, что изменённое значение `seed` остаётся после вычисления выражения.

Таким образом, строка

```python
((seed := -~seed) * seed + -~-seed) % mod
```

Может быть интерпретирована как

```python
((seed + 1) * (seed + 1) - seed) % mod
```

Таким образом, значение `g1` вычисляется по формуле

![img4](./src/img4.png)

Раскрывая скобки получим

![img5](./src/img5.png)

Мы можем вычислить `g1`, зная что `x1 = ord('d') = 100` (т.к. флаг начинается с `donnuCTF{`), `e1 = 54084` и `n = 64019` по формуле

![img6](./src/img6.png)

```
>>> g1 = (54084 * pow(100, -1, 64019)) % 64019
>>> g1
41513
```

Теперь, мы можем составить уравнение для поиска `seed`

![img7](./src/img7.png)

Такие сравнения можно решить с помощью sage или онлайн калькуляторов.

```python
sage: var('seed')
seed
sage: solve_mod(seed ^ 2 + seed + 1 == 41513, 64019)
[(28995,), (35023,)]
sage:
```

Получили два корня `x1 = 28995` и `x2 = 35023`. Не заморачиваясь проверкой корней, можем написать скрипт для расшифровки флага и попробовать оба корня. Фактически мы можем использовать скрипт для шифрования, немного его изменив

```python
def generator(seed, mod):
	for i in range(100):
		yield((seed := -~seed) * seed + -~-seed) % mod


mod = 64019
enc = [54084, 27604, 3282, 26722, 61736, 1001, 62309, 37331, 34255, 14307, 62569, 59696, 51933, 33047, 31188, 5703, 6977, 44713, 54910, 9982, 55344, 23729, 13244, 18992, 23519, 43736, 32090, 38916, 22016, 2851, 20090, 28801, 39710, 17447, 59221, 10138, 51530, 63651, 60912, 38358, 42431, 57996]
flag = ""

seed = 28995

gamma = generator(seed, mod)
for byte in enc:
	flag += chr((byte * pow(next(gamma), -1, mod)) % mod)

print(flag)
```

При запуске скрипт выдаст ошибку, тогда меняем `seed` на `35023` и запускаем опять.